name: Deploy to Firebase

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - beta
          - preview
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
  DEPLOYMENT_ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}

jobs:
  # Pre-deployment validation and security checks
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deployment_ready: ${{ steps.validation.outputs.ready }}
      security_status: ${{ steps.security.outputs.status }}
      build_status: ${{ steps.build.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies
        run: |
          echo "📦 Installing dependencies..."
          npm ci --prefer-offline --no-audit

      - name: Validate environment variables
        id: env-validation
        run: |
          echo "🌍 Validating environment variables..."
          
          MISSING_VARS=""
          REQUIRED_VARS="NEXTAUTH_SECRET NEXTAUTH_URL FIREBASE_PROJECT_ID"
          
          for var in $REQUIRED_VARS; do
            if [ -z "${!var}" ]; then
              echo "❌ Missing required environment variable: $var"
              MISSING_VARS="$MISSING_VARS $var"
            else
              echo "✅ $var is configured"
            fi
          done
          
          if [ -n "$MISSING_VARS" ]; then
            echo "::error::Missing required environment variables:$MISSING_VARS"
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "ready=true" >> $GITHUB_OUTPUT
          fi

      - name: Security audit
        id: security
        run: |
          echo "🔒 Running security audit..."
          
          # Run npm audit and capture results
          if npm audit --audit-level=moderate --json > audit-result.json; then
            CRITICAL=$(jq '.metadata.vulnerabilities.critical // 0' audit-result.json)
            HIGH=$(jq '.metadata.vulnerabilities.high // 0' audit-result.json)
            MODERATE=$(jq '.metadata.vulnerabilities.moderate // 0' audit-result.json)
            
            echo "Security scan results:"
            echo "  Critical: $CRITICAL"
            echo "  High: $HIGH"
            echo "  Moderate: $MODERATE"
            
            if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
              echo "::error::Critical or high security vulnerabilities found"
              echo "status=failed" >> $GITHUB_OUTPUT
              
              # Show detailed vulnerability information
              echo "Vulnerability details:"
              jq -r '.vulnerabilities | to_entries[] | "\(.key): \(.value.severity) - \(.value.title)"' audit-result.json
              exit 1
            elif [ "$MODERATE" -gt 0 ]; then
              echo "::warning::Moderate security vulnerabilities found"
              echo "status=warning" >> $GITHUB_OUTPUT
            else
              echo "✅ No significant security vulnerabilities found"
              echo "status=passed" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Security audit failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Code quality checks
        run: |
          echo "🧹 Running code quality checks..."
          
          # Lint check
          echo "Running ESLint..."
          npm run lint:check
          
          # TypeScript check
          echo "Running TypeScript validation..."
          npm run type-check

      - name: Check for security patterns
        run: |
          echo "🔍 Scanning for potential security issues..."
          
          # Check for potential hardcoded secrets (more precise patterns)
          if grep -rE '(api[_-]?key|secret|password|token).*[=:]\s*["\'][a-zA-Z0-9+/]{16,}' --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" . | grep -v node_modules | grep -v ".git" | grep -v ".env.example" | grep -v "NEXTAUTH_SECRET.*example"; then
            echo "::error::Potential hardcoded secrets found in source code"
            exit 1
          fi
          
          # Check for TODO/FIXME markers that might indicate incomplete security implementations
          if grep -rE 'TODO.*security|FIXME.*security|TODO.*auth|FIXME.*auth' --include="*.js" --include="*.ts" --include="*.jsx" --include="*.tsx" . | grep -v node_modules; then
            echo "::warning::Security-related TODOs found - please review before deployment"
          fi

      - name: Test build locally
        id: build
        run: |
          echo "🔨 Testing production build..."
          
          # Clean previous builds
          npm run clean
          
          # Test build
          if npm run build; then
            echo "✅ Production build successful"
            echo "status=success" >> $GITHUB_OUTPUT
            
            # Check build size
            BUILD_SIZE=$(du -sh .next | cut -f1)
            echo "Build size: $BUILD_SIZE"
            
            # Verify critical files exist
            if [ ! -f ".next/BUILD_ID" ]; then
              echo "::error::Build incomplete - missing BUILD_ID"
              exit 1
            fi
          else
            echo "❌ Production build failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Final validation
        id: validation
        run: |
          if [ "${{ steps.security.outputs.status }}" = "failed" ] || [ "${{ steps.build.outputs.status }}" = "failed" ]; then
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "❌ Pre-deployment checks failed"
            exit 1
          else
            echo "ready=true" >> $GITHUB_OUTPUT
            echo "✅ All pre-deployment checks passed"
          fi

  # Run tests (can be skipped in emergency)
  test-suite:
    name: Run Test Suite
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.deployment_ready == 'true' && github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Run tests
        run: |
          echo "🧪 Running full test suite..."
          npm run ci:test
          
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            test-results/
            playwright-report/
          retention-days: 7

  # Build for deployment
  build-for-deployment:
    name: Build for Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, test-suite]
    if: always() && needs.pre-deployment-checks.outputs.deployment_ready == 'true' && (needs.test-suite.result == 'success' || needs.test-suite.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --production=false

      - name: Build application
        run: |
          echo "🔨 Building application for ${{ env.DEPLOYMENT_ENVIRONMENT }}..."
          
          # Set environment-specific configurations
          case "${{ env.DEPLOYMENT_ENVIRONMENT }}" in
            "production")
              npm run build:production
              ;;
            "beta")
              npm run build:beta
              ;;
            *)
              npm run build
              ;;
          esac

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            .next/
            out/
            public/
            package.json
            next.config.js
            firebase.json
          retention-days: 7

  # Deploy to Firebase
  deploy:
    name: Deploy to Firebase
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, test-suite, build-for-deployment]
    if: |
      always() && 
      needs.pre-deployment-checks.outputs.deployment_ready == 'true' && 
      needs.build-for-deployment.result == 'success' &&
      (needs.test-suite.result == 'success' || needs.test-suite.result == 'skipped') &&
      (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    environment:
      name: ${{ env.DEPLOYMENT_ENVIRONMENT }}
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Firebase CLI
        run: npm install -g firebase-tools

      - name: Deploy to Firebase
        id: deploy
        run: |
          echo "🚀 Deploying to Firebase (${{ env.DEPLOYMENT_ENVIRONMENT }})..."
          
          case "${{ env.DEPLOYMENT_ENVIRONMENT }}" in
            "production")
              firebase deploy --only hosting:production --project ${{ env.FIREBASE_PROJECT_ID }} --token ${{ secrets.FIREBASE_TOKEN }}
              echo "url=https://${{ env.FIREBASE_PROJECT_ID }}.web.app" >> $GITHUB_OUTPUT
              ;;
            "beta")
              firebase deploy --only hosting:beta --project ${{ env.FIREBASE_PROJECT_ID }} --token ${{ secrets.FIREBASE_TOKEN }}
              echo "url=https://beta---${{ env.FIREBASE_PROJECT_ID }}.web.app" >> $GITHUB_OUTPUT
              ;;
            "preview")
              CHANNEL_ID="pr-${{ github.event.number || github.run_number }}"
              firebase hosting:channel:deploy $CHANNEL_ID --project ${{ env.FIREBASE_PROJECT_ID }} --token ${{ secrets.FIREBASE_TOKEN }} --expires 7d
              echo "url=https://${{ env.FIREBASE_PROJECT_ID }}--$CHANNEL_ID.web.app" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Comment deployment URL on PR
        if: github.event_name == 'pull_request' && env.DEPLOYMENT_ENVIRONMENT == 'preview'
        uses: actions/github-script@v7
        with:
          script: |
            const url = "${{ steps.deploy.outputs.url }}";
            const comment = `🚀 **Preview Deployment Ready!**
            
            Your changes have been deployed to a preview environment:
            
            🔗 **Preview URL:** ${url}
            
            This preview will be available for 7 days.
            
            ---
            *Deployment ID: ${{ github.run_id }}*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Post-deployment verification
  post-deployment-checks:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: deploy
    if: needs.deploy.result == 'success'
    steps:
      - name: Health check
        run: |
          echo "🏥 Performing post-deployment health check..."
          
          DEPLOYMENT_URL="${{ needs.deploy.outputs.url }}"
          
          # Wait for deployment to be available
          echo "Waiting for deployment to be ready..."
          sleep 30
          
          # Basic health check
          if curl -f -s "$DEPLOYMENT_URL" > /dev/null; then
            echo "✅ Deployment is accessible"
          else
            echo "❌ Deployment health check failed"
            exit 1
          fi
          
          # Check specific endpoints if they exist
          ENDPOINTS="/api/health /api/auth/session"
          for endpoint in $ENDPOINTS; do
            if curl -f -s "$DEPLOYMENT_URL$endpoint" > /dev/null; then
              echo "✅ $endpoint is accessible"
            else
              echo "⚠️  $endpoint returned non-200 status (might be expected)"
            fi
          done

      - name: Performance check
        run: |
          echo "⚡ Running basic performance check..."
          
          DEPLOYMENT_URL="${{ needs.deploy.outputs.url }}"
          
          # Measure page load time
          LOAD_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$DEPLOYMENT_URL")
          echo "Page load time: ${LOAD_TIME}s"
          
          # Check if load time is reasonable (less than 5 seconds)
          if (( $(echo "$LOAD_TIME > 5" | bc -l) )); then
            echo "⚠️  Page load time is high: ${LOAD_TIME}s"
          else
            echo "✅ Page load time is acceptable: ${LOAD_TIME}s"
          fi

  # Cleanup on failure
  cleanup-on-failure:
    name: Cleanup on Deployment Failure
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure() && needs.deploy.result == 'failure'
    steps:
      - name: Cleanup failed deployment
        run: |
          echo "🧹 Cleaning up failed deployment..."
          
          # In a real scenario, you might want to:
          # - Rollback to previous version
          # - Clean up temporary resources
          # - Notify team of failure
          
          echo "Deployment failed - manual intervention may be required"
          
      - name: Create incident issue
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `🚨 Deployment Failure - ${new Date().toISOString()}`;
            const body = `## Deployment Failure Report
            
            **Deployment Details:**
            - Environment: ${{ env.DEPLOYMENT_ENVIRONMENT }}
            - Commit: ${{ github.sha }}
            - Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            **Failure Stage:** Deploy to Firebase
            
            **Next Steps:**
            1. Review workflow logs
            2. Check deployment environment configuration
            3. Verify Firebase permissions and tokens
            4. Consider manual deployment if urgent
            
            **Auto-fix Status:** 
            The auto-fix workflow should be triggered automatically to address common issues.
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'deployment-failure', 'urgent']
            });

  # Deployment summary
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, test-suite, build-for-deployment, deploy, post-deployment-checks]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "📊 Deployment Summary"
          echo "==================="
          echo "Environment: ${{ env.DEPLOYMENT_ENVIRONMENT }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo ""
          echo "Job Results:"
          echo "- Pre-deployment checks: ${{ needs.pre-deployment-checks.result }}"
          echo "- Test suite: ${{ needs.test-suite.result }}"
          echo "- Build: ${{ needs.build-for-deployment.result }}"
          echo "- Deploy: ${{ needs.deploy.result }}"
          echo "- Post-deployment: ${{ needs.post-deployment-checks.result }}"
          echo ""
          
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "✅ Deployment completed successfully!"
            echo "🔗 Deployment URL: ${{ needs.deploy.outputs.url }}"
          else
            echo "❌ Deployment failed!"
            echo "Check the workflow logs and auto-fix system for resolution."
          fi